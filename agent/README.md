到底什么是Agent
============

# 引言
AI agents 是一个随着大模型热潮而兴起的重要概念。


虽然agent这个词现在被频繁地提起，但它究竟是什么，是如何运作的，很多人其实并不清楚。

# 什么是Agent

很多人都知道，现在的大模型，比如GPT-4o、DeepSeek之类的, 他们回答问题很厉害,逻辑也很强。

但平时我们用他们的时候呢 ，会发现一个限制，他们无法感知或者是改变外界环境。

这句话是什么意思呢，我举一个例子来给你说明一下。

比如 你想让GPT-4o帮你写一个贪吃蛇游戏，它确实可以给你代码，但是写完之后，像把代码写入到文件这种事情，还是得你自己动手,也就是说 ，大模型无法改变外界环境 .

而且有没有一种可能 ,你其实已经有一些贪吃蛇的代码了，你只是想让模型帮你，基于这些代码来改写，增加一些功能。

在这种情况下，你就必须把你已有的代码，复制给GPT-4o才行。

我们不主动告诉GPT-4o的话，他是无法自己查到这些代码的，这就是大模型无法感知外界环境的体现。

所以综合来看 ，大模型是无法感知或者是改变外部环境的。

那有没有办法解决掉这个问题呢，其实是有的，我们给它接上对应的工具就可以了。

比如说是读写文件内容的工具，查看文件列表的工具，运行终端命令的工具。

工具就像是大模型的感官和四肢，有了工具，大模型就可以自己查询已有文件，自己写入代码，自己运行程序，整个过程不需要我们插手，完全自动化。

像这样，把一个大模型和一堆工具组装起来，变成一个，能感知和改变外界环境的智能程序，我们就称它为agent。

通常agent用一个机器人来表示 ，这与大模型的大脑图标，形成了鲜明的对比，毕竟agent有了感官和四肢嘛，能自己独立做事了，就像一个机器人一样。

![](./img/img1.png)

# Agent类型
agent呢有很多类型，前面举的是编程类的agent，它可以用来开发程序。

除此之外，还有一些agent可以做PPT，有一些agent可以深度搜索等。

总的来说，agent的类型有很多，擅长的领域呢，也各不相同。


下面我们来举几个具体点的例子，第一个例子便是大名鼎鼎的claude code。

claude code是一个用于编程的agent，我们只需要给他提交任务，他便会调用大模型和各种工具，来帮我们写代码，直至完成任务。

整个过程中，你只需要告诉claude code需要做的任务，别的基本上什么也不用动。

再举一个例子，今年年初比较火的Manus，它也是一个agent。

在这个例子中
用户希望Manas帮
他比较几个手机的性能
照相等能力
为了解决用户的问题
Manas会生成执行计划
搜索并浏览相关网页
最后把报告整理成一个页面
展示给用户看
整个过程基本上也不需要用户插手
Manus利用大模型和一些工具
就可以解决掉用户的问题
好相信到这里呢
你对agent就有一个大致的了解了
下面呢我们就来讲讲agent的运行模式
agent的运行有很多种模式
其中最有名的一种是react
react本身是一个缩写
它的全称是reasoning and acting
也就是思考与行动
react可能是目前
使用最为广泛的agent运行模式
如果你要学习agent的实现原理
那你就绝对绕不开react
这个模式
最初由2022年10月份的一篇论文提出
虽然
距离现在已经有接近三年的时间了
但是他所提出的agent的运行模式
仍然有着非常广泛的使用
说他是目前使用最为广泛的
agent的运行模式
也不为过
在这种模式下
用户先提交任务
然后agent先做思考
英文是thought
他思考后会决定是否调用工具
如果是的话
他便会去调用合适的工具
比如读取文件写入文件内容之类的
react称这一步是行动
英文是action
在行动后
agent会去查看工具的执行结果
比如所读取的文件内容
写入是否成功等等
react称这一步是观察
也就是观察工具执行结果
英文是observation
在观察之后
react会继续思考
它会再次判断是否需要调
用工具如果还是需要的话
他就会继续重复之前所说的行动
观察思考的流程
直到某个时刻
他认为不需要再调用工具了
可以直接给出结论了
此时他就输出了最终答案
英文是final answer
整个流程到此结束
所以从这个流程图里面也可以看出
react流程的核心步骤是thought action
observation和final answer
记住这几个词
我们后面呢会用到
了解了react模式的流程之后
下一个问题就是
这种react模式是如何实现的
为什么模型拿到用户问题之后
会先思考再行动
他为什么不直接行动
是因为模型就这么训练的吗
不是的
这跟模型的训练过程关系不大
大部分的奥秘呢
其实都集中在系统提示词上
系统提示词
是跟用户问题一起送给模型的提示词
它规定了模型的角色
运行时要遵守的规则
以及各种环境的信息等等
比如我们在系统提示词里面写
你的回答必须包含两个XML标签
一个叫做question
用于存放用户的问题
一个叫做answer
用于存放你的回答
你把这个系统提示词
和用户问题一起发给大模型
在这种情况下
大模型便会遵循这种规范来输出答案
上面举的是一个简单的例子
如果你想要模型按照react模式
返回答案的话呢
那你的系统提示词就会更加复杂一些
我这里呢
就有一个具体的例子
这个系统提示词大致有5个部分
分别是职责描述
示例可用工具注意事
项和环境信息
我们来仔细读一下
首先看职责描述部分
你需要解决一个任务
为此你需要将任务分解为多个步骤
对于每个步骤
首先使用thought思考要做什么
然后使用action调用个工具
工具的执行结果
会通过observation返回给你
持续这个思考和行动的过程
直到你有足够多的信息来提供
final answer这段话呢
其实就是在描述
我们刚才的那个react执行流程图
我们希望大模型
按照react这个标准来运作
后面呢
则是专门说明了每个标签的功能
紧接着我举了几个例子
比如说第一个用户的问题是
埃菲尔铁塔有多高
模型呢
就先用thought标签做了一些思考
然后再使用action调用了get height工具
传入的参数呢是埃菲尔铁塔
工具的返回结果
通过observation返回给了模型
模型接到结果之后呢
他再做了一些思考
然后就给出了最终的答案
这个就是一个非常典型的react流程
后面的例子2呢
其实也是类似
只不过是他调用工具调用了两遍啊
这个我们就不细说了
再往后
我这里列举了一些可用的工具
分别用于读取文件内容
写入文件内容和运行终端命令
都是非常常用的功能
然后呢我们列举了一些注意事项
就是在这里
而且
告诉了大模型相关的一些环境信息
比如说是当前的操作系统目录
和目录下的文件列表等等
下面
我们就来演示一下如何使用这个系统
提示词我们用
deep seek来举例
我们先把我们的系统提示词复制一下
然后粘贴进来
作为用户输入的一部分
之后再在后面加上具体要完成的任务
写一个贪吃蛇游戏
使用HTML CSS和JS实现
代码分别放在不同的文件中
有一点需要提一下
按照规范的做法
系统提示词和用户任务
应该分开传给模型
但DeepSeek并没有提供
单独提交系统提示词的地方
所以呢
我们就把系统提示词和用户任务
合在一起
当成一条消息提交给他
这样的处理方式
在大多数的情况下也是没有问题的
模型依然能够按照预期运行
好让我们提交任务
可以看到deep sleep开始运行了
让我们稍等一下
让它运行完毕
可以看出
它按照我们的要求
先在thought标签里面思考了一下
然后他使用action标签
请求调用write to file工具
来写入index点html文件
这后面就是具体的文件内容了
大家注意我的措辞啊
大模型请求调用工具
这里体现的是请求两个字
大模型本身是不能调用工具的
调用工具的是agent的工具调用组件
这里大模型只能是请求
现在如果运行的是一个真的agent的话
他便会去调用工具
背后的write to file函数
写入html文件内容
不过我们现在在模拟嘛
我们就假设调用已经完成了
并且假设工具的返回结果是写入成功
所以我们回复observation写入成功
拿到这个结果后
deep seek又开始运行了
这次
他还是先用thought标签思考了一下
然后再使用action标签
请求写入CSS文件的内容
我们照例回复写入成功
deep sleep又开始返回了
让我们稍等一下
可以看出
deep seek还是先用thought思考
再用action请求写入GS文件的内容
我们还是回复写入成功
然后deep seek的返回就有了些变化
因为3个必要的文件
都已经写入完成了
不需要再调用工具了
因此
deep seek在thought之后返回了一个final answer
整个回答就彻底结束了
你看
这就是react模式真正运行时的节奏
每一步都按照系统提示词的要求来
thought action observation thought action observation
一直到任务完成
此时会输出thoughts和final answer
系统提示词
就相当于给模型安排了一个迷你剧本
它会严格按照这个剧本
一步一步地走完
前面我们用deep seek
演示了一个agent的运行流程
可以看到
整个流程的关键在于系统提示词
它决定了模型该如何一步步运行
其实在这个系统提示词的基础上
再加上一些配套的代码
我们就可以搭建出一个
真正可用的react agents
实际上我已经把这个agent写好了
就放在我的GitHub仓库里
有需要的同学可以自行获取
接下来
我先演示一下这个agent的使用过程
随后再带大家一起看一遍它的代码
我已经进入到这个agent
所处的项目目录了
我们先执行一下
tree命令
看一下
这个项目目录里面都有什么文件
这里文件很多啊
但实际上你只有两个文件
需要留意一下
第一个是agent的派文件
这个文件里面
就写了我们的agent的代码
我们等会要运行的就是这个文件
另外一个是Snake文件夹
它里面什么也没有
我用tree命令给你证实下
可以看出确实没有任何文件
等会儿我就会让agent把代码
写入到这个文件夹里面
好介绍完毕
下面我们来执行一下这个agent
让你看看它是如何运作的
首先我们启动一下这个agent
我们用的命令是UV run agent pipe Snake
前面的UV run agent点PI
就是用来启动agent点PI文件的
后面的Snake
是agent点PI这个脚本的第一个参数
意思是告诉agent点PI
他要操作的项目目录是Snake
代码就写在那里面
agent点PI
首先向我们询问需要完成的任务
我们的任务就是写一个贪吃蛇游戏
使用HTML CSS和JS实现
代码分别放在不同的文件中
回车agent点PI已经开始运行了
他现在正在请求大模型
我这里采用了同步返回的机制
所以
需要等模型把所有内容都生成完毕
之后才能看到结果
其实也可以用流式返回的模型
返回几个字就能看到几个字
这样可能效果更好一点
不过代码的复杂度会增加
所以综合权衡之后
我就没有使用流失返回
好看到第一轮的结果了
我们的结果一共是包含三个部分
thoughts action observation
跟我们之前在deep seek那里看到的
一模一样
这里的action是请求调用write to file工具
写入index
点h t m l文件
后面的observation
显示的就是具体的调用结果了
写入成功
注意啊这个写入成功可不是模拟的
这是真的执行了write to file工具
工具也真的返回了写入成功这几个字
好这个呢
是第一部分
我们把滚动条往下拉一拉
看一下剩下的部分是个什么样子的
后面的流程呢
也基本类似
可以看到在observation之后
agent会再次进球模型
然后
agent就又进行了一段thoughts action observation
这一轮写入的是CSS
我们再把滚动条往下拖一拖
在这里
我们就可以看到第三轮的thoughts action
observation这次写入的是js
最后所有文件都写完之后
它会给出thoughts和final answer
整个流程就结束了
再看看Snake文件夹
确实三个文件都有了
执行indexhtml
看看游戏能不能玩
可以看到界面出来了
我们动一下啊
确实也是能动的
然后吃一个红色的方块呢
也是可以吃的
左上角是分数
看来运转的非常顺畅
从这个结果中也可以判断出
我们这个agent做的非常成功
完全可以作为一个
简化版的cloud code来使用
下面
我们来看一下这个agent的具体代码
我们首先从入口处看起
这里面的projects directory就是我
们传给agent ipy文件的第一个参数
也就是Snake那个文件夹
tools代表可用的工具列表
我们这里给出了三个
分别用于读取文件
写入文件和运行终端命令
这些都是很实用的函数
我们可以大体看一下
这个呢是读取文件
这个是写入文件函数
这个呢是运行终端命令
从这里可以看出
工具确实就是函数
让我们回到原来的主链路
继续往下看
这里的react agents
便是这个文件的核心了
它是一个类
构造这个类的时候呢
需要提供三个参数
第一个是工具列表
这个我们前面已经构建好了
这里直接传了进来
第二个是我们要用的模型
我们这里用的是G B D 4 o
第三个是项目目录
也就是Snake文件夹
传好了这三个参数之后
我们便获取到了一个agent变量
之后我们会提示用户输入任务内容
然后我们把用户任务传入agent
点run函数
这个函数是react agent的核心
调用它就相当于是启动了这个agent
之前提到的thoughts
action observation和final answer
都是在这个函数内部依次处理的
它处理好了之后
会给出一个最终答案final answer
并且把这个final answer输出到屏幕上
到这里主链路就结束了
可以看到这段代码的核心是react agents
我们来看一下它里面写了些什么
首先它这里定义了一些自身的属性
分别是工具列表模型
项目目录和模型调用
客户端到
这里构造函数呢就结束了
后面我们要看的函数
便是这个agent的重点run函数
这个函数的参数呢
是用户输入的任务
在函数的内部
它先构建了一个message列表
里面有两个元素
分别是系统提示词和用户问题
系统提示词
是用render system prompts这个函数来渲染的
它接受一个参数是系统提示词模板
模板里面的内容是这个样子的
跟我们之前讲的那个系统提示词
基本上是一样的
只不过这个模板里面有一些占位符
比如说是工具列表
操作系统当前目录下的文件列表
等等这些站位符
都是render system prompt函数在运行的时候
填进去的
在拼接好了message列表之后
我们使用call model函数调用了模型
拿到了模型的执行结果
然后
我们提取出返回结果中的thought部分
并且打印了出来
然后代码会检测thought之后的内容
是不是final answer
如果是的话
我们返回这个final answer
函数执行到此结束
如果不是的话
那content里面一定就包含action了
我们此时就把action给解析出来
提取出其中的函数名和参数列表
然后判断了下
当前工具是不是运行终端命令的工具
如果是的话
我们会提示用户是否继续
因为运行终端命令比较危险
所以现在一般用于编程的agent
都会在运行终端命令之前
主动询问用户是否要执行
之后没有问题的话呢
我们就会去执行工具背后的函数了
并且把执行结果放到observation里面
再把observation放到message列表里面
因为我们在一个while循环里面
所以呢
我们下一步还会来到循环的开头
这里继续请求模型
我们给call model
这个函数传了message列表作为参数
工具执行结果不是作为observation
放到了message列表里面了吗
而message又传给了模型
这样
模型就可以拿到工具的执行结果了
它进而就可以根据工具的执行结果
推测下一步要干什么
所以总结一下这个while循环做的事情
请求模型
提取thoughts检测final answer
提取action并执行其中的工具
这个过程会一直重复下去
直到模型返回了final answer为止
回想一下
这正是我们之前所提到的
react运行流程
为了确保你彻底明白
这其中发生了什么
我们来画个agent的流程图
整个流程图里面有两个角色
用户和agent
而agent又可以分成三个部分
分别是模型工具
也就是函数
还有agent主程序
agent主程序这个词我们之前没有提过
其实就是agent里面
负责串联整个流程的代码逻辑
它会在合适的时候调用工具
或者是模型
等等你可以大致理解为
我们刚才代码里面的那个run函数
下面我们就来画个流程图
看看这4个角色之间是怎么沟通的
在用户提交任务之后
任务先到了agent主程序
这里agent主程序会先去调用模型
模型返回thoughts和action
agent主程序
把thoughts和action打印给用户看
然后去调用action里面的指定工具
工具执行完毕之后返回结果
agent主程序把结果发回给用户看
然后把这个工具执行结果
加入到历史消息列表里面
然后再次重复这个框中的流程
也就是请求模型
并处理thoughts action和observation的逻辑
直到某个时刻
在请求模型后
模型认为用户的任务已经完成了
不需要再调用工具了
它就会返回thoughts和final answer
agent主程序
把thoughts和final answer展示给用户看
整个流程就结束了
这就是一个完整的
react agent的问答流程
前面我们讲了
如何使用react模式来构建一个agent
react是目前最常见
使用最广泛的agent的构建模式
但它不是唯一的方案
除了react之外
还有很多其他的运行模式
其中很多agent的运行过程就是先规划
再执行比如我们之前演示过的Manas
如果你仔细看的话
就会发现
它在一开始回答的时候
会构建一个待办列表
后面的执行过程呢
都是遵循这个待办列表来
而cloud code中
也会经常看到这种先创建to do
再去执行的情况
这种先规划再执行的模式
目前并没有一个统一的名字
而且每个agent的实现
多多少少也会有一些差别
我们今天来讲一个
其中比较有名的实现
是郎晨提出来的plan and execute模式
从总体上来看
他也是遵循了先规划再执行的
流程只不过
他的流程
引入了一些动态修改规划的环节
这使得他的方案有了很大的灵活性
我们先用实习图
来画一下plan and execute模式的运行流程
首先我们要搞清楚
这个实习图里面有多少个角色
粗分下来的话
那肯定只有两个了
一个是用户
另外一个呢
是plan and execute agents
不过
既然要研究plan and execute agent的运行流程
我们就肯定要搞清楚
这个agent的组成部分
首先
它里面有一个负责出执行计划的模型
我们称它为plan模型
我们在运行的过程中
还需要根据每一步的执行结果
来动态的调整计划
因此我们还需要一个
负责修改执行计划的模型
我们称它为reply模型
plan和reply模型可以是同一个
也可以分成两个
都是可以的
我们暂且将它们列为两个
除了这两个模型之外
我们还需要一个负责执行这个计划中
每一个步骤的agents
我们称它为执行agents
对你没看错
这个plan and execute agents内部呢
还有一个agent
这种agent套agent的设计方案
其实也是比较常见的
最后跟react那个流程一样
我们还需要一个agent的主程序
负责串联整个流程
这就是plan and execute agents的全部模块了
下面我们就把它们放在流程图里面
看看各个模块之间是如何运作的
首先用户会把问题提给agent的主程序
比如我们的问题
就可以是今年澳网男子冠军
的家乡是哪里
这里的奥网
指的是
每年举办的澳大利亚网球公开赛
也就是个体育赛事了
agent主程序接到这个问题之后
会把这个问题发给plan模型
让它给出具体的执行步骤
比如一个可能的执行步骤就是这样的
先查询当前日期
然后查询在当前年份下
奥网男子冠军的名字
比如当前时间是2025年的话
就查询2025年的奥网男子冠军的名字
如果当前年份是2024年的话
那就查询2024年的奥网男子冠军的名字
查出名字后
我们再根据这个名字
来查询这个冠军的家乡
没错
这就是一个非常合理的执行步骤
那计划有了之后
agent的主程序
便会把这个计划传给执行agent
让他去执行这个计划中的第一步
也就是查询当前日期的那个步骤
这个执行agent
可以用我们之前讲的react模式来运行
它内置一个网络搜索工具
这样呢它就可以通过搜索网络
来查询当前日期了
当然执行agent
也完全可以用别的模式来运行
plan and execute模式呢
只要求执行agent
能够完成指定的步骤就行
至于它的运行模式
是不是react内置工具有哪些
他完全不关心
执行agent内部一顿操作之后
就吐出了一个执行结果
并返回了回去
然后agent的主程序会把用户问题
执行计划和执行记录都发给reply模型
让它生成一个新的执行计划
毕竟
我们拿到了第一步的执行结果了嘛
多了一些信息
情况呢可能
会发生些变化
把原计划改改是再正常不过的事情了
那AJ的主程序接到新的执行计划之后
它便会回头再重复这个框中的流程
在我们这个例子中
这个框中的流程一共会运行三轮
对应了执行计划里面的三步
每一轮都包含两个环节
一个是执行环节
一个是re plan环节
为了能够让你彻底明白
我们模拟一下这个循环中的三轮
让你看看
每一轮的执行环节和reply环节
都具体发生了些什么事情
在模拟开始前
我先打个预防针
为了节省时间
我在模拟时讲解的速度会稍微快一些
如果你听不懂
建议在合适的时候稍微停一下
好让我们开始
首先是第一轮
在执行阶段
我们把执行计划发给执行agent
让他处理其中的第一步
执行agent返回之后
我们把他给出的执行结果
加入到历史执行记录里
然后把用户问题
第一个执行计划和历史执行记录
一起发给reply模型
让他给出第二个执行计划
第一个执行计划和第二个执行计划
有两点不同
这里我专门说一下
首先原来查询当前日期的那一步
就不用出现在第二个执行计划里面了
毕竟已经执行完了
不用再执行了
另外
查询奥网男子冠军名字的这一步呢
也发生了一些变化
在第一个执行计划中
它叫做
查询对应日期的奥网男子冠军名字
在第二个执行计划中
它叫做查询2025年的澳网男子冠军名字
毕竟日期已经查出来了因
此我们可以直接把具体的年份
放到执行计划里
这样
执行agent接到的任务就更加精确了
然后进入到第二轮
在这一轮中
我们同样先取出最新的执行计划
发给执行agent
让他执行其中的第一步
拿到执行结果后
我们再把执行结果
加入到历史执行记录中
然后在replan阶段
把用户问题执行计划和历史执行记录
发给replan模型
拿到第三个执行计划
在第三轮中
我们还是先取出执行计划
让执行agent处理其中的第一步
当然现在也只剩一步了
执行之后
我们就可以拿到一个执行结果
把执行结果加入到历史执行记录里
然后再把用户问题执行计划
和历史执行记录
都发给reply模型
让它再生成一个
哎好像所有的任务都已经完成了
没有步骤要做了吧
没错在最后一轮中
Replay模型会发现
所有的步骤都已经做完了
用户的问题可以回答出来了
此时reply模型返回的
就不是最新的执行计划了
而是最终的答案
所以在流程图里面
我们要把执行计划换成最终答案
a站的主程序接到这个最终答案之后
便会把这个答案转发给用户
整个流程也就结束了
所以回头看一下这个流程图
我们之前说
agent的主程序请求reply模型
给出一个新的执行计划
这个说法呢
其实并不准确
更准确的说法是
agent的主程序请求reply模型
给出一个新的执行计划
或者是返回最终答
案如果还有步骤要执行的话呢
那就给出一个新的计划
如果没有步骤要做了
用户的问题已经回答出来了
那reply模型就返回最终答案就好了
因此reply模型的返回呢
也有两种可能性
新的执行计划或者是最终答案
这样呢才是一个准确的流程图
相信到这里为止
你对plan and execute流程
就有一个非常清晰的认识了
不过有些人可能想要
plan and execute的具体实现
代码langcheng官方提供了一份
你可以到这个页面里面自行获取
今天的视频呢
就到此结束了
别忘了点赞关注
我们下次再见拜拜

